### HTTP

> 应用层协议，默认端口 `80`. 无连接无状态.

* HTTP请求分为三部分：状态行、请求头、消息主体；

* HTTP响应分为三部分：状态行、响应头、响应正文；

```
Keep-Alive: timeout=5, max=100
=>
timeout=5表示可以持续5s；max=100表示最多接收100个请求之后就断开连接
```

```
请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3
=> 管线化后
请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3
```

#### 优点

* 连接可以复用（管线化）

* 通信简单快速

##### HTTP/1.0

* `请求-应答` 模式：即每个请求/应答客户与服务器之间都要新建一个连接，完成之后立即断开；

##### HTTP/1.1

* `Keep-Alive` 模式：客户与服务器之间连接持久有效（但是不是一直有效，存在 timeout，max等设置），保持了当前 TCP 的连接。客户端可以通过在请求中发送 `Connection: close` 明确要求服务器关闭 TCP 连接。

* 引入了 `管道机制`，同一个 TCP 连接里面，客户端可以发送多个请求。

* 分块传输编码：`Transfer-Encoding=chunked`，表明消息体由数量未定的块组成，并以一个大小为 0 的块结束。

* 队首阻塞：虽然 `Keep-Alive` 复用 TCP 连接使得客户端发请求没有了限制，但是服务器队列还是会一个一个执行请求，数据通信是按次执行的，服务器只有处理完前一个请求才会进行下一个请求处理，这样如果前面的请求很慢，则会导致很多请求排队。

##### HTTP/2

* 二进制分帧机制：`流` 和 `帧`

* 多路复用：HTTP/1.x 为了发起多个并行请求，则需要使用多个 TCP 连接，而且不同浏览器对 TCP 连接会有数量限制，导致请求多的时候，就存在等待的情况。而 HTTP/2 中客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。

* 服务器推

#### 缺点

* 通信使用明文（不加密），内容容易被篡改

* 不验证通信方的身份，因此可能遭遇伪装

* 无法证明通信报文的完整性，所以可能被篡改

### HTTPS

> HTTP + 加密 + 认证 + 完整性保护 = HTTPS

认证保证对方是那个自己打算通信的有资质的服务器；加密保证通信过程不被人篡改。HTTP 直接与 TCP 通信，当有了 SSL 之后，则变成了先和 SSL 通信，再由 SSL 和 TCP 通信。HTTPS 处理速度会慢，因为多了一层 SSL。

* SSL 加密消耗内存和CPU等资源

* SSL 本身通信也会慢

### 常见状态码

| 状态码类型 | 状态码 | 作用 |
| --------- | ----- | ---- |
| 1XX       |       | 代表请求已被接受，属于临时响应 |
| 2XX       |       | 代表请求已被服务器接收，理解，接受 |
|           | 200 OK   | 请求成功 |
|           | 201 Created | 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时创建的话，应当返回 '202 Accepted' |
|           | 202 Accepted | 服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止 |
|           | 204 No Content | 服务器成功处理了请求，没有返回任何内容
| 3XX       |       | 需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明 |
|           | 304 Not Modified | 表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。 |
| 4XX       |       | 客户端错误 |
|           | 400 Bad Request | 由于客户端的问题导致服务器不能或不会处理该请求。|
|           | 401 Unauthorized | 用户没有必要的凭据。 |
|           | 403 Forbidden | 服务器已经理解请求，但是拒绝执行它。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。 |
|           | 404 Not Found | |
|           | 405 Method Not Allowed | 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 |
|           | 406 Not Acceptable | 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。 |
|           | 413 Request Entity Too Large | 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。 |
|           | 414 Request-URI Too Long | 表示请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。 |
| 5XX       |       | 服务器错误 |
|           | 500 Internal Server Error | |
|           | 502 Bad Gateway | 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 |
|           | 503 Service Unavailable | 由于临时的服务器维护或者过载，服务器当前无法处理请求。 |
|           | 504 Gateway Timeout | 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。 |
