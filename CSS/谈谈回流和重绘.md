### 谈谈回流和重绘？如何避免这些？

#### 浏览器渲染过程

1. 我们都知道，构成一个页面最基本的就是 `html+css+js`，`js` 被用来做一些 `dom` 操作，所有有的时候也不一定会有，那么浏览器在构建一个页面的时候，会解析三个东西：

- html：浏览器会把 `html` 解析成 `dom` 树

- css：浏览器会把 `css` 解析成 `css` 规则树（又叫 `cssom`，`css` 对象模型）

- js：加载 `js` 脚本用来操作 `dom` 等

2. 浏览器加载了上述的文件之后，解析完成，会通过解析之后的 `dom` 树和 `cssom` 进行构建，生成 `render` 树，又叫 `渲染树`。值得注意的是：`渲染树` 只包含可见的节点，诸如 `script` 标签，`link` 标签是不会在 `渲染树` 当中的，那些被设置了 `display: none` 的标签也不会显示在渲染树中。

3. 在生成 `渲染树` 的过程中，进行 `回流`，得到节点的 `位置`，`大小` 等几何信息。

4. 根据 `渲染树` 和 `回流` 得到的节点信息，浏览器 `GPU` 绘制得到真实 DOM。

#### 回流是什么

浏览器在生成 `渲染树` 的过程中，需要计算他们在浏览器视窗中的 `位置`，`大小` 等信息，这一计算过程就叫做 `回流` （也叫做 `重排`）。**`回流` 一定会触发 `重绘`。** 以下几种方式会触发 `回流`：

- 页面添加或者删除元素（这一过程产生了页面布局的变化）

- 元素位置变化

- 元素尺寸发生变化（包括元素本身的大小，也包括元素的边框，内外边距）

- 元素内容发生变化

- 浏览器窗口发生变化（`回流` 本身就是按照浏览器视窗来计算位置和大小信息的）

#### 重绘是什么

浏览器在知道了 `渲染树` 和他们在视窗内的 `位置`，`大小` 等信息后，需要把他们转换成实际的像素节点，这一过程就叫做 `重绘`。**`重绘` 不一定是 `回流` 产生的**。比如只是修改了元素的颜色，元素本身的位置和大小信息并没有修改，这一过程是不会产生 `回流` 的，浏览器只进行 `重绘` 操作就行了。以下几种方式会触发 `重绘`：

- 元素颜色变化，背景变化

- 元素隐藏和显示（visibility）

- 其他会导致元素外观变化的方式

#### 浏览器优化机制

`回流` 过程本身是一个计算消耗，浏览器不会在每次触发 `回流` 的时候就立即执行计算，这样会导致很大的性能问题。大部分浏览器都会通过 `队列` 批量执行 `回流` 过程来进行优化。浏览器会按照自己的方式批量更新 `队列`，但是我们也可以用一些 `强制手段进行刷新队列` 操作，来直接触发 `回流` 从而触发 `重绘`。以下几种方式可以强制触发 `回流`：

- 访问 `offsetTop、offsetLeft、offsetWidth、offsetHeight`

- 访问 `scrollTop、scrollLeft、scrollWidth、scrollHeight`

- 访问 `clientTop、clientLeft、clientWidth、clientHeight`

这些方法都是为了获取最新的布局信息，所以浏览器不得不刷新队列，将最新的布局信息返回。所以在用到这些方法的时候，最好把值进行缓存起来。

#### 如何在编码中减少回流和重绘

知道了触发 `回流` 和 `重绘` 的原因，就可以对症下药。

- 不适用 table 布局，可能很小的改动就会重新触发 table 重新布局

- 合并多次对元素样式的修改

```css
const el = document.getElementById('test');
el.style.padding = '5px'; // 触发回流
el.style.borderLeft = '1px'; // 又一次触发
el.style.borderRight = '2px'; // 又触发一次

// 最好的做法是，为 el 添加一个 class，将所有的样式变化丢到 class 内处理
```

- 合并可能合并的 dom 操作

- 对于复杂的动画效果，使其绝对定位，脱离文档流，避免触发回流

- 动画使用 requestAnimationFrame

- css 硬件加速（GPU 加速）

  - transform
  - opacity

#### 其他

- Q1：为什么说要减少 dom 操作？

> 因为 `dom` 本身属于 `渲染引擎` 所管辖的范畴，`js` 的执行是属于 `js引擎` 所管辖的范畴，两者之间的通信操作本身就是一种跨界操作，所以会慢。

- Q2：script 标签中 `defer` 和 `async` 的区别是什么？

> - `<script src="script.js"></script>` 这种方式加载脚本，浏览器遇到时候，会立即加载该脚本，并执行，此时会阻塞 `dom` 和 `css` 的加载。

> - `<script async src="script.js"></script>` 这种方式加载脚本，表示异步引入脚本，脚本引入成功之后就执行，所以说无法保证先后顺序，谁先加载好谁先执行。这一方式不会影响 `dom` 的渲染。

> - `<script defer src="script.js"></script>` 这种方式加载脚本，表示脚本延迟执行。这一方式保证了脚本可以在文档完全被解析之后再执行。
